// You can see my library at https://github.com/solalyth/atcoder-env-rs
#[cfg(not(debug_assertions))] #[allow(unused)]
mod mylib {
    #![allow(non_upper_case_globals)]
    
    pub const SUBMISSION: bool = true;
    
    pub const us998: usize = 998244353;
    pub const i998: i128 = 998244353;
    pub const us107: usize = 1000000007;
    pub const i107: i128 = 1000000007;
    
    pub type Mint = ac_library::ModInt998244353;
    
    pub use {
        util::{
            printer::{Printer, end, EndFlag},
            traits::*
        },
        
        proconio::{input, marker::{Bytes as bytes, Chars as chars, Usize1 as usize1, Isize1 as isize1}, source::{Source, line::LineSource, once::OnceSource}},
        std::io::{BufReader, BufRead, stdin},
        std::collections::{VecDeque, HashMap, HashSet, BTreeMap, BTreeSet},
        std::mem::swap,
        itertools::{Itertools, iproduct, izip},
        superslice::Ext,
        num::integer::{gcd, lcm, Roots},
    };
    
    
    pub mod data_struct {
        pub mod bitset {
            use std::{fmt::Debug, ops::{BitAnd, BitOr, BitXor, Index, Not}}; #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)] pub struct BitSet { len: usize, value: usize } impl BitSet { pub fn new(value: bool, len: usize) -> Self { BitSet { value: if value {!0} else {0}, len }.masked() } pub fn from(value: usize, len: usize) -> Self { BitSet { value, len }.masked() } fn masked(mut self) -> Self { self.value &= BitSet::max(self.len); self } pub fn sup(len: usize) -> usize { 1<<len } pub fn max(len: usize) -> usize { (1<<len)-1 } pub fn generate(len: usize) -> impl DoubleEndedIterator<Item = Self> { (0..Self::sup(len)).map(move |i| BitSet { value: i, len }) } pub fn raw(&self) -> usize { self.value } pub fn set(&mut self, idx: usize, value: bool) { assert!(idx < self.len); if value { self.value |= 1<<idx; } else { self.value &= !(1<<idx); } } pub fn count_true(&self) -> usize { self.value.count_ones() as usize } pub fn count_false(&self) -> usize { self.len - self.count_true() } pub fn is_full(&self) -> bool { self.value == BitSet::max(self.len) } pub fn is_empty(&self) -> bool { self.value == 0 } pub fn iter(self) -> impl DoubleEndedIterator<Item = bool> { (0..self.len).map(move |i| self[i]) } } impl BitAnd for BitSet { type Output = Self; fn bitand(mut self, rhs: Self) -> Self::Output { assert_eq!(self.len, rhs.len); self.value &= rhs.value; self } } impl BitOr for BitSet { type Output = Self; fn bitor(mut self, rhs: Self) -> Self::Output { assert_eq!(self.len, rhs.len); self.value |= rhs.value; self } } impl BitXor for BitSet { type Output = Self; fn bitxor(mut self, rhs: Self) -> Self::Output { assert_eq!(self.len, rhs.len); self.value ^= rhs.value; self } } impl Not for BitSet { type Output = Self; fn not(mut self) -> Self::Output { self.value = !self.value; self.masked() } } impl Debug for BitSet { fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, "{:?}({})", self.iter().collect::<Vec<_>>(), self.value) } } impl Index<usize> for BitSet { type Output = bool; fn index(&self, index: usize) -> &Self::Output { assert!(index < self.len); static A: [bool; 2] = [false, true]; &A[self.value>>index & 1] } }
        }
        pub mod compress {
            pub struct Compress<T: Ord> (Vec<T>); impl<T: Ord> Compress<T> { pub fn new() -> Self { Compress(vec![]) } pub fn entry(&mut self, value: T) { self.0.push(value); } pub fn calc(mut self) -> Compressed<T> { self.0.sort_unstable(); self.0.dedup(); Compressed(self.0) } } pub struct Compressed<T: Ord> (Vec<T>); impl<T: Ord> Compressed<T> { pub fn len(&self) -> usize { self.0.len() } pub fn key(&self, value: &T) -> usize { self.0.binary_search(value).unwrap() } pub fn restore(&self, key: usize) -> &T { &self.0[key] } pub fn inner(&self) -> &Vec<T> { &self.0 } }
        }
        pub mod unionfind {
            use crate::nest; #[derive(Clone, Copy)] enum Node { Leader(usize), Child(usize) } #[derive(Clone)] pub struct UnionFind { nodes: Vec<Node> } impl UnionFind { pub fn new(len: usize) -> Self { UnionFind { nodes: vec![Node::Leader(1); len] } } fn leader_and_size(&mut self, u: usize) -> (usize, usize) { let mut now = u; let mut stack = vec![]; loop { match self.nodes[now] { Node::Child(par) => { stack.push(now); now = par; } Node::Leader(size) => { for i in stack { self.nodes[i] = Node::Child(now); } return (now, size); } } } } pub fn leader(&mut self, u: usize) -> usize { self.leader_and_size(u).0 } pub fn size(&mut self, u: usize) -> usize { self.leader_and_size(u).1 } pub fn is_same(&mut self, u: usize, v: usize) -> bool { self.leader(u) == self.leader(v) } pub fn merge(&mut self, u: usize, v: usize) -> bool { let ((mut ul, us), (mut vl, vs)) = (self.leader_and_size(u), self.leader_and_size(v)); if ul != vl { if us < vs { (ul, vl) = (vl, ul); } self.nodes[ul] = Node::Leader(us+vs); self.nodes[vl] = Node::Child(ul); } ul != vl } pub fn group(&mut self, mut u: usize) -> Vec<usize> { u = self.leader(u); (0..self.nodes.len()).filter(|&v| self.leader(v) == u).collect() } pub fn groups(&mut self) -> Vec<Vec<usize>> { let mut out = nest![void; self.nodes.len()]; for u in 0..self.nodes.len() { out[self.leader(u)].push(u); } out.retain(|v| v.len() != 0); out } } type WeightType = i128; #[derive(Clone)] pub struct WeightedUnionFind { nodes: Vec<Node>, diff: Vec<WeightType> } impl WeightedUnionFind { pub fn new(len: usize) -> Self { WeightedUnionFind { nodes: vec![Node::Leader(1); len], diff: vec![0; len] } } fn leader_and_size(&mut self, u: usize) -> (usize, usize) { let mut now = u; let mut stack = vec![]; loop { match self.nodes[now] { Node::Child(par) => { stack.push(now); now = par; } Node::Leader(size) => { for &child in stack.iter().rev() { let Node::Child(parent) = self.nodes[child] else { unreachable!(); }; self.nodes[child] = Node::Child(now); self.diff[child] += self.diff[parent]; } return (now, size); } } } } pub fn leader(&mut self, u: usize) -> usize { self.leader_and_size(u).0 } pub fn size(&mut self, u: usize) -> usize { self.leader_and_size(u).1 } pub fn is_same(&mut self, u: usize, v: usize) -> bool { self.leader(u) == self.leader(v) } pub fn weight(&mut self, u: usize, v: usize) -> Result<WeightType, ()> { if self.leader(u) == self.leader(v) { Ok(-self.diff[u] + self.diff[v]) } else { Err(()) } } pub fn merge(&mut self, u: usize, v: usize, mut w: WeightType) -> Result<bool, ()> { let ((mut ul, us), (mut vl, vs)) = (self.leader_and_size(u), self.leader_and_size(v)); if ul != vl { if us < vs { (ul, vl) = (vl, ul); w = -w; } self.nodes[ul] = Node::Leader(us+vs); self.nodes[vl] = Node::Child(ul); self.diff[vl] = self.diff[u] - self.diff[v] + w; Ok(true) } else { if -self.diff[u] + self.diff[v] == w { Ok(false) } else { Err(()) } } } pub fn group(&mut self, mut u: usize) -> Vec<usize> { u = self.leader(u); (0..self.nodes.len()).filter(|&v| self.leader(v) == u).collect() } pub fn groups(&mut self) -> Vec<Vec<usize>> { let mut out = nest![void; self.nodes.len()]; for u in 0..self.nodes.len() { out[self.leader(u)].push(u); } out.retain(|v| v.len() != 0); out } }
        }
        pub mod segtree {
            pub use crate::mylib::traits::abstracts::{Map, Monoid}; use std::marker::PhantomData; use std::ops::{Bound, RangeBounds}; use std::{fmt::Debug, mem::replace, ops::{Deref, DerefMut, Index, IndexMut}, slice::SliceIndex}; fn ceil_log(len: usize) -> u32 { (len.max(2)-1).ilog2() + 1 } pub struct Segtree<Mn: Monoid, Mp: Map<Mn::Set>> { tree: Vec<Mn::Set>, map_tree: Vec<Mp::F>, log: u32, } pub struct EntryAll<'a, Mn: Monoid, Mp: Map<Mn::Set>> { seg: &'a mut Segtree<Mn, Mp>, changed: bool } pub struct Entry<'a, Mn: Monoid, Mp: Map<Mn::Set>> { seg: &'a mut Segtree<Mn, Mp>, i: usize, changed: bool } impl Segtree<Nop<()>, Nop<()>> { pub fn new_no_map<Mn: Monoid>(len: usize) -> Segtree<Mn, Nop<Mn::Set>> { let log = ceil_log(len) + 1; let size = 1 << log; Segtree { tree: vec![Mn::e(); size], map_tree: vec![(); size], log } } pub fn new_no_monoid<T: Clone + Debug, Mp: Map<T>>(init: T, len: usize) -> Segtree<Nop<T>, Mp> { let log = ceil_log(len) + 1; let size = 1 << log; Segtree { tree: vec![init; size], map_tree: vec![Mp::id(); size], log } } pub fn new<Mn: Monoid, Mp: Map<Mn::Set>>(len: usize) -> Segtree<Mn, Mp> { let log = ceil_log(len) + 1; let size = 1 << log; Segtree { tree: vec![Mn::e(); size], map_tree: vec![Mp::id(); size], log } } } impl<Mn: Monoid, Mp: Map<Mn::Set>> Segtree<Mn, Mp> { pub fn hint_monoid(&self, _: Mn) {} pub fn hint_map(&self, _: Mp) {} fn interpret(&self, range: impl RangeBounds<usize>) -> (usize, usize) { let l = match range.start_bound() { Bound::Included(v) => *v, Bound::Excluded(v) => v+1, Bound::Unbounded => 0 }; let r = match range.end_bound() { Bound::Included(v) => v+1, Bound::Excluded(v) => *v, Bound::Unbounded => self.len() }; assert!(l <= r && r <= self.len(), "specified: [{l}, {r}), valid: [0, {})", self.len()); (l+self.len(), r+self.len()) } pub fn len(&self) -> usize { self.tree.len()/2 } fn act(&mut self, i: usize) { let f = replace(&mut self.map_tree[i], Mp::id()); let is_leaf = self.map_tree.len() <= 2*i; if !is_leaf { Mp::comp(&f, &mut self.map_tree[2*i]); Mp::comp(&f, &mut self.map_tree[2*i+1]); } if !Mn::NOP || (Mn::NOP && is_leaf) { Mp::map(&f, &mut self.tree[i]); } } fn act_range(&mut self, l: usize, r: usize) { for i in (1..self.log).rev() { if (l >> i) << i != l { self.act(l >> i); } if (r >> i) << i != r { self.act(r >> i); } } } fn calc(&mut self, i: usize) { self.tree[i] = Mn::op(&self.tree[2*i], &self.tree[2*i+1]); } pub fn fold(&mut self, range: impl RangeBounds<usize>) -> Mn::Set { assert!(!Mn::NOP); let (mut l, mut r) = self.interpret(range); if !Mp::NOP { self.act_range(l, r); } let (mut outl, mut outr) = (Mn::e(), Mn::e()); while l < r { if l&1 == 1 { if !Mp::NOP { self.act(l); } outl = Mn::op(&outl, &self.tree[l]); l += 1; } if r&1 == 1 { if !Mp::NOP { self.act(r-1); } outr = Mn::op(&self.tree[r-1], &outr); r -= 1; } l >>= 1; r >>= 1; } Mn::op(&outl, &outr) } pub fn map(&mut self, range: impl RangeBounds<usize>, map: Mp::F) { assert!(!Mp::NOP); let (l, r) = self.interpret(range); self.act_range(l, r); { let (mut l, mut r) = (l, r); let (mut lf, mut rf) = (true, true); while l < r { if l&1 != 0 { Mp::comp(&map, &mut self.map_tree[l]); self.act(l); if lf { self.act(l-1); lf = false; } l += 1; } if r&1 != 0 { Mp::comp(&map, &mut self.map_tree[r-1]); self.act(r-1); if rf { self.act(r); rf = false; } r -= 1; } l >>= 1; r >>= 1; } } if !Mn::NOP { for i in 1..self.log { if (l >> i) << i != l { self.calc(l >> i); } if (r >> i) << i != r { self.calc(r >> i); } } } } pub fn max_right(&mut self, mut l: usize, pred: impl Fn(&Mn::Set) -> bool) -> usize { assert!(l <= self.len()); assert!(pred(&Mn::e())); if l == self.len() { return self.len(); } l += self.len(); if !Mp::NOP { for i in (1..self.log).rev() { self.act(l >> i); } } let mut res = Mn::e(); loop { while l&1 == 0 { l >>= 1; } if !Mp::NOP { self.act(l); } let tmp = Mn::op(&res, &self.tree[l]); if !pred(&tmp) { while l < self.len() { l <<= 1; if !Mp::NOP { self.act(l); } let tmp = Mn::op(&res, &self.tree[l]); if pred(&tmp) { res = tmp; l += 1; } } break l - self.len(); } res = tmp; l += 1; let l = l as isize; if (l & -l) != l { break self.len(); } } } pub fn max_left(&mut self, mut r: usize, pred: impl Fn(&Mn::Set) -> bool) -> usize { assert!(r <= self.len()); assert!(pred(&Mn::e())); if r == 0 { return 0; } r += self.len(); if !Mp::NOP { for i in (1..self.log).rev() { self.act((r-1) >> i); } } let mut res = Mn::e(); loop { r -= 1; while 1 < r && r&1 == 0 { r >>= 1; } if !Mp::NOP { self.act(r); } let tmp = Mn::op(&self.tree[r], &res); if !pred(&tmp) { while r < self.len() { r = 2*r + 1; if !Mp::NOP { self.act(r); } let tmp = Mn::op(&self.tree[r], &res); if pred(&tmp) { res = tmp; r -= 1; } } return r + 1 - self.len(); } res = tmp; let r = r as isize; if (r & -r) != r { return 0; } } } pub fn entry<'a>(&'a mut self, idx: usize) -> Entry<'a, Mn, Mp> { assert!(idx < self.len()); let i = idx + self.len(); if !Mp::NOP { for j in (0..self.log).rev() { self.act(i >> j); } } Entry { seg: self, i, changed: false } } pub fn entry_all<'a>(&'a mut self) -> EntryAll<'a, Mn, Mp> { if !Mp::NOP { for i in 1..self.map_tree.len() { self.act(i); } } EntryAll { seg: self, changed: false } } } impl<Mn: Monoid, Mp: Map<Mn::Set>> Debug for Segtree<Mn, Mp> { fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { let mut a = vec![String::new(); self.tree.len()]; for i in (if !Mn::NOP {0} else {self.len()})..self.tree.len() { a[i] += &format!("[{}]", Mn::debug(&self.tree[i])); } if !Mp::NOP { for i in 0..self.map_tree.len() { if !a[i].is_empty() { a[i] += " "; } a[i] += &format!("({})", &Mp::debug(&self.map_tree[i])); } } let max_len = a.iter().map(|s| s.len()).max().unwrap(); let mut out = String::new(); for i in 0..self.log { out += "\n"; for j in (1 << i)..(1 << i+1) { out += &format!("{: <width$}", a[j], width = max_len*(1 << self.log-i-1)); } } write!(f, "{}", &out[1..]) } } impl<'a, Mn: Monoid, Mp: Map<Mn::Set>> Drop for EntryAll<'a, Mn, Mp> { fn drop(&mut self) { if self.changed && !Mn::NOP { for i in (1..self.seg.tree.len()/2).rev() { self.seg.calc(i); } } } } impl<'a, Mn: Monoid, Mp: Map<Mn::Set>, I: SliceIndex<[Mn::Set]>> Index<I> for EntryAll<'a, Mn, Mp> { type Output = I::Output; fn index(&self, index: I) -> &Self::Output { Index::index(&self.seg.tree[self.seg.len()..], index) } } impl<'a, Mn: Monoid, Mp: Map<Mn::Set>, I: SliceIndex<[Mn::Set]>> IndexMut<I> for EntryAll<'a, Mn, Mp> { fn index_mut(&mut self, index: I) -> &mut Self::Output { self.changed = true; let len = self.seg.len(); IndexMut::index_mut(&mut self.seg.tree[len..], index) } } impl<'a, Mn: Monoid, Mp: Map<Mn::Set>> Entry<'a, Mn, Mp> { pub fn map(&mut self, map: &Mp::F) { self.changed = true; Mp::map(map, &mut self.seg.tree[self.i]); } pub fn set(&mut self, value: Mn::Set) -> Mn::Set { self.changed = true; replace(&mut self.seg.tree[self.i], value) } pub fn modify<T>(&mut self, f: impl FnOnce(&mut Mn::Set) -> T) -> T { self.changed = true; f(&mut self.seg.tree[self.i]) } } impl<'a, Mn: Monoid, Mp: Map<Mn::Set>> Drop for Entry<'a, Mn, Mp> { fn drop(&mut self) { if self.changed && !Mn::NOP { for j in 1..self.seg.log { self.seg.calc(self.i >> j); } } } } impl<'a, Mn: Monoid, Mp: Map<Mn::Set>> Deref for Entry<'a, Mn, Mp> { type Target = Mn::Set; fn deref(&self) -> &Self::Target { &self.seg.tree[self.i] } } impl<'a, Mn: Monoid, Mp: Map<Mn::Set>> DerefMut for Entry<'a, Mn, Mp> { fn deref_mut(&mut self) -> &mut Self::Target { self.changed = true; &mut self.seg.tree[self.i] } } pub struct Nop<T: Clone> (PhantomData<T>); impl<T: Clone + Debug> Monoid for Nop<T> { const NOP: bool = true; type Set = T; fn e() -> T { panic!() } fn op(_: &T, _: &T) -> T { panic!() } fn debug(v: &Self::Set) -> String { format!("{v:?}") } } impl<T: Clone> Map<T> for Nop<T> { const NOP: bool = true; type F = (); fn id() -> () { panic!() } fn comp(_: &(), _: &mut ()) { panic!() } fn map(_: &(), _: &mut T) { panic!() } fn debug(_: &Self::F) -> String { "".into() } }
        }
        pub mod inversible {
            #[derive(Clone, Debug)] pub struct InversibleVec { kv: Vec<Option<usize>>, vk: Vec<Option<usize>> } impl InversibleVec { pub fn new(len: usize) -> Self { InversibleVec { kv: vec![None; len], vk: vec![None; len] } } pub fn set(&mut self, key: usize, value: usize) { assert!(self.kv[key].is_none() && self.vk[value].is_none()); self.kv[key] = Some(value); self.vk[value] = Some(key); } pub fn remove_by_key(&mut self, key: usize) -> bool { let Some(value) = self.kv[key] else { return false; }; self.kv[key] = None; self.vk[value] = None; true } pub fn remove_by_value(&mut self, value: usize) -> bool { let Some(key) = self.vk[value] else { return false; }; self.kv[key] = None; self.vk[value] = None; true } pub fn value(&self, key: usize) -> Option<usize> { self.kv[key] } pub fn key(&self, value: usize) -> Option<usize> { self.vk[value] } pub fn contains_value(&self, key: usize) -> bool { self.kv[key].is_some() } pub fn contains_key(&self, value: usize) -> bool { self.vk[value].is_some() } pub fn get_inner_kv(&self) -> &Vec<Option<usize>> { &self.kv } pub fn get_inner_vk(&self) -> &Vec<Option<usize>> { &self.vk } }
        }
    }
    
    pub mod traits {
        pub mod abstracts {
            pub trait Monoid { const NOP: bool = false; type Set: Clone; fn e() -> Self::Set; fn op(lhs: &Self::Set, rhs: &Self::Set) -> Self::Set; fn debug(_: &Self::Set) -> String { "no info".into() } }
            pub trait Map<MnSet: Clone, const NOP: bool = false> { const NOP: bool = false; type F: Clone; fn id() -> Self::F; fn comp(f: &Self::F, g: &mut Self::F); fn map(f: &Self::F, x: &mut MnSet); fn debug(_: &Self::F) -> String { "no info".into() } }
        }
    }
    
    pub mod math {
        pub mod prime {
            use std::collections::BTreeMap;
            pub struct PrimeTable { max: usize, _primes: Vec<usize>, lpf: Vec<usize> }
            impl PrimeTable { pub fn new(max: usize) -> Self { assert!(3 <= max); let mut primes = vec![]; let mut lpf = vec![0; max+1]; for i in 2..=max { if lpf[i] == 0 { primes.push(i); lpf[i] = i; } let lpfi = lpf[i]; for &p in primes.iter().take_while(|&&p| p <= lpfi && i*p <= max) { lpf[i*p] = p; } } PrimeTable { max, _primes: primes, lpf } } pub fn is_prime(&self, v: usize) -> bool { if v <= self.max { self.lpf[v] == v } else { Iterator::chain(self._primes.iter().cloned(), self.max+1..).take_while(|&p| p.pow(2) <= v).all(|p| v%p != 0) } } pub fn fact(&self, mut v: usize) -> BTreeMap<usize, usize> { assert_ne!(v, 0); let mut out = BTreeMap::new(); for p in Iterator::chain(self._primes.iter().cloned(), self.max+1..) { if v <= self.max { while v != 1 { *out.entry(self.lpf[v]).or_default() += 1; v /= self.lpf[v]; } break; } if v < p*p { *out.entry(v).or_default() += 1; break; } while v%p == 0 { v /= p; *out.entry(p).or_default() += 1; } } out } pub fn primes(&self) -> &[usize] { &self._primes } }
        }
    }
    
    pub mod util {
        pub mod printer {
            #![allow(non_camel_case_types, non_upper_case_globals)] use std::{ops::{Shl, Not}, cell::{UnsafeCell, Cell}, mem::transmute, fmt::Write}; use crate::pr; pub struct Printer<const sp: bool = true> { buf: UnsafeCell<String>, endf: EndFlag, prvf: Cell<PreviousFlag> } #[derive(PartialEq, Eq)] pub enum EndFlag { DoNothing, LineFeed, Print } use PreviousFlag::*; #[derive(PartialEq, Eq, Clone, Copy)] enum PreviousFlag { Space, NoSpace, LineHead, } impl Printer { pub fn new(endf: EndFlag) -> Self { Printer { buf: String::new().into(), endf, prvf: LineHead.into() } } } impl<const sp: bool> Printer<sp> { fn push(&self, v: impl PrinterDisplay) { unsafe { let buf = &mut *self.buf.get(); let prvf = self.prvf.replace(if sp {Space} else {NoSpace}); if (prvf == Space || sp) && prvf != LineHead { *buf += " "; } v.pdisp(sp, buf); } } pub fn print(&self) { unsafe { let buf = &mut *self.buf.get(); let prvf = self.prvf.replace(LineHead); if prvf == LineHead { buf.pop(); } pr!("{buf}"); buf.clear(); } } } impl<T: PrinterDisplay, const sp: bool> Shl<T> for &Printer<sp> { type Output = Self; fn shl(self, rhs: T) -> Self::Output { self.push(rhs); self } } impl<'a> Not for &'a Printer<true> { type Output = &'a Printer<false>; fn not(self) -> Self::Output { unsafe { transmute(self) } } } pub struct end; impl<const sp: bool> Shl<end> for &Printer<sp> { type Output = (); fn shl(self, _: end) -> Self::Output { if self.endf == EndFlag::LineFeed { self.prvf.replace(LineHead); self.push('\n'); } else if self.endf == EndFlag::Print { self.print(); } } } trait PrinterDisplay { fn pdisp(&self, sp: bool, buf: &mut String); } macro_rules! fall { ($($t:ty),+) => { $( impl PrinterDisplay for $t { fn pdisp(&self, _: bool, buf: &mut String) { write!(buf, "{self}").unwrap(); } } )+ }; } fall!( u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, f32, f64, char, &str, &String ); impl PrinterDisplay for bool { fn pdisp(&self, _: bool, buf: &mut String) { *buf += if *self {"Yes"} else{ "No" }; }} impl<T: PrinterDisplay> PrinterDisplay for &[T] { fn pdisp(&self, sp: bool, buf: &mut String) { for e in *self { e.pdisp(sp, buf); if sp { *buf += " "; } } if sp && !self.is_empty() { buf.pop(); } } }
        }
        pub mod traits {
            use crate::mylib::util::macros::impl_for; pub trait ChangeMinMax: Sized + PartialOrd + Copy { fn chmax(&mut self, value: Self) -> bool { let tmp = *self < value; if tmp { *self = value; } tmp } fn chmin(&mut self, value: Self) -> bool { let tmp = value < *self; if tmp { *self = value; } tmp } } macro_rules! impl_chminmax { ($($t:ty),+) => { $( impl ChangeMinMax for $t {} )+ }; } impl_for!(ChangeMinMax; u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize, f32, f64); pub trait WrappingAddSignedForPair { const LRUD: [(isize, isize); 4] = [(0, -1), (0, 1), (0, -1), (0, 1)]; fn wrapping_add_signed(self, rhs: (isize, isize)) -> Self; } impl WrappingAddSignedForPair for (usize, usize) { fn wrapping_add_signed(self, rhs: (isize, isize)) -> Self { (self.0.wrapping_add_signed(rhs.0), self.1.wrapping_add_signed(rhs.1)) } }
            pub trait CharUtil: Clone { const lower: [Self; 26]; const upper: [Self; 26]; fn lower_to_us(self) -> usize; fn upper_to_us(self) -> usize; fn flip(self) -> Self; } impl CharUtil for char { const lower: [char; 26] = { let (mut out, mut i) = (['_'; 26], 0); while i < 26 { out[i] = (i+97) as u8 as char; i += 1; } out }; const upper: [char; 26] = { let (mut out, mut i) = (['_'; 26], 0); while i < 26 { out[i] = (i+65) as u8 as char; i += 1; } out }; fn lower_to_us(self) -> usize { self as usize - 97 } fn upper_to_us(self) -> usize { self as usize - 65 } fn flip(self) -> Self { (self as u8 ^ 32) as char } }
        }
        pub mod macros {
            #[macro_export] macro_rules! pr { ($($args:tt)*) => { if !$crate::SUBMISSION { eprint!("\x1b[32m"); print!("{}", format!($($args)*).split('\n').map(|s| format!(">> {s}\n")).reduce(|acc,s| acc+&s).unwrap()); eprint!("\x1b[0m"); } if $crate::SUBMISSION { println!($($args)*); } } } #[macro_export] macro_rules! epr { ($($args:tt)*) => { if !$crate::SUBMISSION { eprint!("\x1b[31m"); print!("{}", format!($($args)*).split('\n').map(|s| format!(">> {s}\n")).reduce(|acc,s| acc+&s).unwrap()); eprint!("\x1b[0m"); } } } #[macro_export] macro_rules! nest { (void; $n:expr) => { vec![vec![]; $n] }; (void; $n:expr $(;$m:expr)+) => { vec![nest![void$(;$m)+]; $n] }; () => { vec![] }; ($e:expr; $n:expr) => { vec![$e; $n] }; ($e:expr; $n:expr $(;$m:expr)+) => { vec![nest![$e$(;$m)+]; $n] }; } #[macro_export] macro_rules! min { ($l:expr, $r:expr) => { { let (l, r) = ($l, $r); if l < r { l } else { r } } }; ($v:expr, $($vl:expr),+) => { min!($v, min!($($vl),+)) }; } #[macro_export] macro_rules! max { ($l:expr, $r:expr) => { { let (l, r) = ($l, $r); if l > r { l } else { r } } }; ($v:expr, $($vl:expr),+) => { max!($v, max!($($vl),+)) }; } #[macro_export] macro_rules! elsedef { ($cond:expr; $v:expr) => { if $cond {$v} else {Default::default()} } } macro_rules! impl_for { ($trait:ty; $($type:ty),+) => { $( impl $trait for $type {} )+ } } pub(crate) use impl_for;
        }
        pub mod func {
            use std::ops::{RangeBounds, Bound::*}; pub fn as_range(range: impl RangeBounds<usize>, sup: usize) -> (usize, usize) { let l = match range.start_bound() { Included(&v) => v, Excluded(&v) => v+1, Unbounded => 0 }; let r = match range.end_bound() { Included(&v) => v+1, Excluded(&v) => v, Unbounded => sup }; if !(l <= r && r <= sup) { panic!("valid: 0..{sup}\ninputed: {l}..{r}"); } (l, r) }
        }
    }
}
