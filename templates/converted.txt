"#![allow(non_snake_case)]\n\n#[cfg(debug_assertions)] #[allow(unused)] use lib::{*, eprintln};\n#[cfg(not(debug_assertions))] use mylib::*;\n\n#[allow(unused_must_use)]\nfn solve(out: &Solver<true>) {\n\tinput! {\n\t\t$1\n\t}\n\t\n\t$0\n}\n\n\n\nfn main() {\n\tlet out = Solver::<true>::new(false); solve(&out); out.print();\n}\n\n#[cfg(not(debug_assertions))]\nmod mylib {\n\t#![allow(dead_code, non_upper_case_globals)]\n\tpub use {\n\t\tproconio::{input, marker::{Chars, Usize1 as usize1, Isize1 as isize1}},\n\t\tstd::cmp::{min, max, Reverse as Rev},\n\t\tstd::collections::{VecDeque, HashMap, HashSet, BTreeMap, BTreeSet, BinaryHeap},\n\t\tstd::mem::swap,\n\t\titertools::Itertools,\n\t\tsuperslice::Ext\n\t};\n\t\n\tpub fn yesno(b: bool) -> &'static str {if b{\"Yes\"}else{\"No\"}}\n\t\n\tuse std::{fmt::Display, ops::{Shl, Shr, Not}, cell::UnsafeCell, mem::transmute, cmp::Ordering};\n\t\n\t// bit\n\ttrait Bit {\n\t\tfn get(&self, n: usize) -> bool;\n\t\tfn set_true(&mut self, n: usize);\n\t\tfn set_false(&mut self, n: usize);\n\t}\n\timpl Bit for usize {\n\t\tfn get(&self, n: usize) -> bool {self>>n&1==1}\n\t\tfn set_true(&mut self, n: usize) {*self|=1<<n;}\n\t\tfn set_false(&mut self, n: usize) {*self&=!(1<<n);}\n\t}\n\t\n\t// mod\n\tpub const i998: i128 = 998244353;\n\tpub const u998: u128 = 998244353;\n\n\ttrait Mod {\n\t\tfn normalize(&self) -> Self;\n\t\tfn inv(&self) -> Self;\n\t\tfn mpow(self, p: Self) -> Self;\n\t}\n\n\timpl Mod for i128 {\n\t\tfn normalize(&self) -> Self {let a=self%i998;if a<0{a+i998}else{a}}\n\t\tfn inv(&self) -> Self {self.mpow(i998-2)}\n\t\tfn mpow(mut self, mut p: Self) -> Self {let mut a=1;while p!=0{if p&1==1{a=a*self%i998;}self=self*self%i998;p<<=1;}a}\n\t}\n\t\n\t// pcmp\n\tpub trait Pcmp: PartialOrd {\n\t\tfn pcmp(a: &Self, b: &Self) -> Ordering {a.partial_cmp(b).unwrap()}\n\t}\n\timpl Pcmp for f64 {}\n\t\n\t\n\t// others\n\t#[macro_export] macro_rules! nest {(void;\\$n:expr)=>{vec![vec![];\\$n]};(void;\\$n:expr\\$(;\\$m:expr)+)=>{vec![nest![void\\$(;\\$m)+];\\$n]};(\\$e:expr;\\$n:expr)=>{vec![\\$e;\\$n]};(\\$e:expr;\\$n:expr\\$(;\\$m:expr)+)=>{vec![nest![\\$e\\$(;\\$m)+];\\$n]};}\n\t#[macro_export] macro_rules! eprintln {(\\$(\\$args:tt)*)=>{}}\n\t\n\t// solver\n\tpub struct Solver<const sp: bool> { v: UnsafeCell<String>, b: bool, bf: UnsafeCell<bool> }\n\timpl<const sp: bool> Solver<sp> {\n\t\tpub fn new(b: bool) -> Solver<true> {Solver::<true>{v:String::new().into(),b,bf:true.into()}}\n\t\tpub fn swapbf(&self, mut v: bool) -> bool {unsafe{swap(&mut*self.bf.get(),&mut v)}v}\n\t\tpub fn push(&self, v: &str) {unsafe{let s=&mut*self.v.get();if sp||self.swapbf(sp)&&s.len()!=0{s.push(' ');}s.push_str(v);}}\n\t\tpub fn print(&self) {unsafe{let s=&mut*self.v.get();if s.len()!=0{println!(\"{}\", s);s.clear();}}}\n\t}\n\timpl<T: Display, const sp: bool> Shl<T> for &Solver<sp> {type Output=Self; fn shl(self,rhs:T)->Self::Output{self.push(&format!(\"{}\",rhs)); self}}\n\t#[allow(non_camel_case_types)] pub struct end;\n\timpl<const sp: bool> Shl<end> for &Solver<sp> {type Output=(); fn shl(self,_:end)->Self::Output{self.swapbf(true);if cfg!(debug_assertions)||self.b{self.print();}()}}\n\timpl<'a> Not for &'a Solver<true> {type Output = &'a Solver<false>; fn not(self) -> Self::Output {unsafe{transmute(self)}}}\n}"