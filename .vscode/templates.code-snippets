{
	"Initialize for AtCoder": {
		"scope": "rust",
		"prefix": "init",
		"body": "#![allow(non_snake_case)]\n\nuse mylib::*;\n\nconst INTERACTIVE: bool = false;\n\n#[allow(unused_must_use)]\nfn solve<_T: BufRead>(#[allow(unused)] out: &Printer, mut stdin: impl Source<_T>) {\n\tmacro_rules! input {(\\$(\\$t:tt)*)=>{mylib::input!(from &mut stdin, \\$(\\$t)*);}}\n\tinput! {\n\t\t$1\n\t}\n\t\n\t$0\n}\n\n\n\nfn _input() -> String { String::from(\"\") }\n\n\nfn main() {\n\tlet out = Printer::new(if SUBMISSION && !INTERACTIVE {EndFlag::LineFeed} else {EndFlag::Print});\n\t\n\tif !SUBMISSION {\n\t\tlet inp = _input();\n\t\tif !inp.is_empty() {\n\t\t\tsolve(&out, OnceSource::from(inp.as_str()));\n\t\t} else {\n\t\t\tsolve(&out, LineSource::new(BufReader::new(stdin())));\n\t\t}\n\t} else {\n\t\tif !INTERACTIVE {\n\t\t\tsolve(&out, OnceSource::new(BufReader::new(stdin())));\n\t\t} else {\n\t\t\tsolve(&out, LineSource::new(BufReader::new(stdin())));\n\t\t}\n\t}\n\tout.print();\n}"
	},
	
	"stderr print": {
		"scope": "rust",
		"prefix": "epr",
		"body": "epr!(\"{$0}\");"
	},
	
	"vectors": {
		"scope": "rust",
		"prefix": "vec",
		"body": "v![$0];"
	},
	
	"match with unreachable": {
		"scope": "rust",
		"prefix": "match_unreachable",
		"body": [
			"match $1 {",
			"\t$0",
			"\t_ => { unreachable!(); }",
			"}"
		]
	},
	
	"match LRUD": {
		"scope": "rust",
		"prefix": "match_lrud",
		"body": [
			"match $0 {",
			"\t'L' => { /* i-- */ }",
			"\t'R' => { /* i++ */ }",
			"\t'U' => { /* j-- */ }",
			"\t'D' => { /* j++ */ }",
			"}"
		]
	},
	
	/* "match unreachable": {
		"scope": "rust",
		"prefix": "_",
		"body": "_ => { unreachable!(); }"
	}, */
	
	"累積和": {
		"scope": "rust",
		"prefix": "snp_wa",
		"body": [
			"// [l..r] の和 == wa[r] - wa[l]",
			"let mut wa = vec![0; $0.len()+1];",
			"for i in 0..$0.len() { wa[i+1] = wa[i] + $0[i]; }"
		]
	},
	
	"imos 法": {
		"scope": "rust",
		"prefix": "snp_imos",
		"body": [
			// 入力が [0, a, b, c, ...] とかだと楽なんだけどな～～
			
			"// [l..r] の加算: { sa[l] += v; sa[r] -= v; }",
			"let mut sa = vec![0; $0.len()];",
			"for i in 0..$0.len() { sa[i] = $0[i] - if i!=0 {$0[i-1]} else {0}; }",
			"",
			"",
			"",
			"let mut rest = vec![0; $0.len()];",
			"for i in 0..$0.len() { rest[i] = sa[i] + if i!=0 {rest[i-1]} else {0}; }"
		]
	},
	
	"Dijkstra 法": {
		"scope": "rust",
		"prefix": "snp_dijkstra",
		"description": "cost が最小になるように探索をする例。非負重みグラフなら使える。",
		"body": [
			"let mut cost = vec![inf as _; ${1:edge_len}];",
			"cost[${2:init_edge}] = 0;",
			"let mut queue = BTreeSet::from([(0, $2)]); // 代入済み、更新待ち",
			"",
			"while let Some((c, i)) = queue.pop_first() {",
			"    for &(to, pathc) in &E[i] {",
			"        let toc = c + pathc;",
			"        if cost[to] <= toc { continue; } // 更新できない条件",
			"        ",
			"        queue.remove((cost[to], to));",
			"        cost[to] = toc;",
			"        queue.insert((toc, to));",
			"    }",
			"}"
		]
	},
	
	"Bellman-Ford 法": {
		"scope": "rust",
		"prefix": "snp_bellman_ford",
		"description": "",
		"body": [
			"let mut cost = vec![inf as _; ${1:edge_len}];",
			"cost[${2:init_edge}] = 0;",
			"",
			"for i in 0..$1-1 {",
			"    for &(to, pathc) in &E[i] {",
			"        let toc = cost[i] + ",
			"        ",
			"        ",
			"        ",
			"    }",
			"    ",
			"}"
		]
	},
	
	"幅優先探索 (BFS)": {
		"scope": "rust",
		"prefix": "snp_bfs",
		"body": [
			"let mut queue = VecDeque::from([$1]);",
			"while let Some(q) = queue.pop_front() {",
			"\tfor &to in &E[q] {",
			"\t\tif $2 { continue; }",
			"\t\t",
			"\t\t$0",
			"\t\t",
			"\t\t$3",
			"\t\tqueue.push_back(to);",
			"\t}",
			"}"
		]
	},
	
	"test": {
		"scope": "rust",
		"prefix": "test",
		"body": [
			"#[test]",
			"fn $1() {",
			"\t$0",
			"}"
		]
	}
}
