{
	"Initialize for AtCoder": {
		"scope": "rust",
		"prefix": "init",
		"body": "#![allow(non_snake_case)]\n\n#[cfg(debug_assertions)] #[allow(unused)] use lib::{*, eprintln};\n#[cfg(not(debug_assertions))] use mylib::*;\n\n#[allow(unused_must_use)]\nfn solve(out: &Solver) {\n\tinput! {\n\t\t$1\n\t}\n\t\n\t$0\n}\n\n\n\nfn main() {\n\tlet out = Solver::new(false); solve(&out); out.print();\n}\n\n#[cfg(not(debug_assertions))] #[allow(dead_code)]\nmod mylib {\n\tpub use {\n\t\tproconio::{input, marker::{Chars, Usize1}},\n\t\tstd::cmp::{min, max, Reverse as Rev},\n\t\tstd::collections::{VecDeque, HashMap, HashSet, BTreeMap, BTreeSet, BinaryHeap},\n\t\titertools::Itertools,\n\t\tsuperslice::Ext\n\t};\n\t\n\tpub fn yesno(b: bool) -> &'static str {if b{\"Yes\"}else{\"No\"}}\n\t\n\tuse std::{fmt::Display, ops::{Shl, Shr}, cell::UnsafeCell};\n\t\n\t// bit\n\t#[derive(Clone, Copy)] struct Bit(usize);\n\timpl Bit { fn get(self, n: usize) -> bool {self.0>>n&1==1} fn set(self, n: usize) -> Bit {Bit(1>>n|self.0)} }\n\timpl Shl<usize> for Bit { type Output = Bit; fn shl(self, rhs: usize) -> Self::Output {self.set(rhs)} }\n\timpl Shr<usize> for Bit { type Output = bool; fn shr(self, rhs: usize) -> Self::Output {self.get(rhs)} }\n\t\n\t// mod\n\tpub const MOD: u128 = 998244353;\n\tpub fn mpow(b: u128, p: u128) -> u128 {if p<=1{b.pow(p as u32)%MOD}else{let sqr=mpow(b.pow(2)%MOD,p/2);if p%2==0{sqr}else{sqr*b%MOD}}}\n\t\n\t// others\n\t#[macro_export] macro_rules! nest {(void;\\$n:expr)=>{vec![vec![];\\$n]};(void;\\$n:expr\\$(;\\$m:expr)+)=>{vec![nest![void\\$(;\\$m)+];\\$n]};(\\$e:expr;\\$n:expr)=>{vec![\\$e;\\$n]};(\\$e:expr;\\$n:expr\\$(;\\$m:expr)+)=>{vec![nest![\\$e\\$(;\\$m)+];\\$n]};}\n\t#[macro_export] macro_rules! eprintln {(\\$(\\$args:tt)*)=>{}}\n\t\n\t// solver\n\tpub struct Solver { v: UnsafeCell<String>, b: bool }\n\timpl Solver {pub fn new(b: bool) -> Self {Solver{v:String::new().into(),b}} pub fn print(&self) {unsafe{let s=&mut*self.v.get();println!(\"{}\", s);s.clear();}}}\n\timpl<T: Display> Shl<T> for &Solver {type Output=Self; fn shl(self,rhs:T)->Self::Output{unsafe{let s=&mut*self.v.get();if s.len()!=0{s.push(' ');}s.push_str(&format!(\"{}\",rhs));}self}}\n\t#[allow(non_camel_case_types)] pub struct end;\n\timpl Shl<end> for &Solver {type Output=(); fn shl(self,_:end)->Self::Output{if cfg!(debug_assertions)||self.b{self.print();}()}}\n}"
	},
	
	"Interactive": {
		"scope": "rust",
		"prefix": "snp_interactive",
		"body": "let mut stdin = proconio::source::line::LineSource::new(std::io::BufReader::new(std::io::stdin()));"
	},
	
	"println": {
		"scope": "rust",
		"prefix": "pr",
		"body": "println!(\"{}$1\", $0);"
	},
	
	"eprintln": {
		"scope": "rust",
		"prefix": "epr",
		"body": "eprintln!(\"{$0}\");"
	},
	
	"return": {
		"scope": "rust",
		"prefix": "return",
		"body": "return; "
	}
}
